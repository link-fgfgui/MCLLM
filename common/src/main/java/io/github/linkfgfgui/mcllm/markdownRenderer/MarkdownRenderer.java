package io.github.linkfgfgui.mcllm.markdownRenderer;

import com.bawnorton.mcchatgpt.config.Config;
import net.minecraft.network.chat.*;
import net.minecraft.resources.ResourceLocation;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

//generated by chatgpt
public class MarkdownRenderer {

    private static final Pattern BLOCK_PATTERN = Pattern.compile("(?s)```(.*?)```"); // ```代码```
    private static final Pattern INLINE_CODE_PATTERN = Pattern.compile("`([^`]+)`"); // `代码`
    private static final Pattern THINKTAG_PATTERN = Pattern.compile("(?s)<think>\\s*(.*?)\\s*</think>");
    private static final Pattern MARKDOWN_PATTERN = Pattern.compile(
            "(?m)^### (.*?)$" +         // 三级标题
                    "|^## (.*?)$" +             // 二级标题
                    "|^# (.*?)$" +              // 一级标题
                    "|\\*\\*(.*?)\\*\\*" +      // 粗体
                    "|\\*(.*?)\\*" +            // 斜体
                    "|__(.*?)__" +              // 下划线
                    "|~~(.*?)~~" +              // 删除线
                    "|\\[(.*?)]\\((.*?)\\)" +   // 超链接
                    "|([^\\n]+)"                // 普通行文本
    );

    public static Component render(String markdown, Boolean usageIsPresent, long tokenUsed, float cost, String reasoning_content) {
        // 预处理：分离代码块
        List<Component> result = new ArrayList<>();

        int last = 0;
        Matcher blockMatcher = BLOCK_PATTERN.matcher(markdown);
        while (blockMatcher.find()) {
            // 代码块前面的部分递归处理
            String before = markdown.substring(last, blockMatcher.start());
            result.addAll(parseMarkdown(before));

            // 代码块内容
            String code = blockMatcher.group(1);
            Component codeComponent = Component.literal(code)
                    .withStyle(style -> style
                            .withColor(TextColor.fromRgb(0xAAAAAA))
                            .withFont(ResourceLocation.tryParse("minecraft:default")) // 可模拟固定宽字体
                    );
            result.add(codeComponent);
            last = blockMatcher.end();
        }

        if (last < markdown.length()) {
            result.addAll(parseMarkdown(markdown.substring(last)));
        }

        result.addFirst(Component.literal("<LLM> "));
        if (Config.getInstance().isThinkModel) {
            if (!reasoning_content.isEmpty()) {
                result.add(1, getReasoningContentComponent(reasoning_content));
            }
        }
        if (result.getLast().getString().equals("\n")) {
            result.removeLast();
        }

        if (Config.getInstance().isShowCost) {
            if (usageIsPresent) {

                result.add(Component.literal(" (Costs: $" + cost + ")")
                        .setStyle(
                                Style.EMPTY.withHoverEvent(
                                        new HoverEvent(
                                                HoverEvent.Action.SHOW_TEXT,
                                                Component.translatable("mcllm.token.usage", tokenUsed, cost)
                                        )
                                )
                        ));
            }
        }
        Component ret = Component.empty();
        for (Component component : result) {
            ret = ret.copy().append(component);
        }
        return ret;
    }

    private static List<Component> parseMarkdown(String text) {
        List<Component> components = new ArrayList<>();
        // 1. 提取 think tag
        Matcher thinkMatcher = THINKTAG_PATTERN.matcher(text);
        if (thinkMatcher.find()) {
            // 处理标签前内容
            String before = text.substring(0, thinkMatcher.start());
            components.addAll(parseMarkdown(before));
            // 处理 think 标签内容并加悬浮提示
            String thinkText = thinkMatcher.group(1);
            Component thinkComp = getReasoningContentComponent(thinkText);
            // 递归处理标签后内容
            if (Config.getInstance().isThinkModel) components.add(thinkComp);
            int startAfter = thinkMatcher.end();
            while (startAfter < text.length() && Character.isWhitespace(text.charAt(startAfter))) {
                startAfter++;
            }
            String after = text.substring(startAfter);
            components.addAll(parseMarkdown(after));
            return components;
        }
        // 2. 无 think 标签，则按行拆分并走原有逻辑
        String[] lines = text.split("\\r?\\n");
        for (String line : lines) {
            if (line.isEmpty()) {
                continue;
            }
            components.addAll(parseLineMarkdown(line));
            components.add(Component.literal("\n"));
        }
        return components;
    }

    private static List<Component> parseLineMarkdown(String line) {

        List<Component> components = new ArrayList<>();
        Matcher matcher = MARKDOWN_PATTERN.matcher(line);
        while (matcher.find()) {
            if (matcher.group(1) != null) { // ###
                components.add(Component.literal(matcher.group(1))
                        .withStyle(style -> style.withColor(TextColor.fromRgb(0xAAAAFF)).withBold(true)));
            } else if (matcher.group(2) != null) { // ##
                components.add(Component.literal(matcher.group(2))
                        .withStyle(style -> style.withColor(TextColor.fromRgb(0x55AAFF)).withBold(true)));
            } else if (matcher.group(3) != null) { // #
                components.add(Component.literal(matcher.group(3))
                        .withStyle(style -> style.withColor(TextColor.fromRgb(0x00AAFF)).withBold(true)));
            } else if (matcher.group(4) != null) { // **bold**
                components.add(Component.literal(matcher.group(4))
                        .withStyle(style -> style.withBold(true)));
            } else if (matcher.group(5) != null) { // *italic*
                components.add(Component.literal(matcher.group(5))
                        .withStyle(style -> style.withItalic(true)));
            } else if (matcher.group(6) != null) { // __underline__
                components.add(Component.literal(matcher.group(6))
                        .withStyle(style -> style.withUnderlined(true)));
            } else if (matcher.group(7) != null) { // ~~strike~~
                components.add(Component.literal(matcher.group(7))
                        .withStyle(style -> style.withStrikethrough(true)));
            } else if (matcher.group(8) != null && matcher.group(9) != null) { // [text](url)
                components.add(Component.literal(matcher.group(8))
                        .withStyle(style -> style
                                .withColor(TextColor.fromRgb(0x55AAFF))
                                .withUnderlined(true)
                                .withClickEvent(new ClickEvent(ClickEvent.Action.OPEN_URL, matcher.group(9)))));
            } else if (matcher.group(10) != null) { // plain + inline code
                components.addAll(parseInlineCode(matcher.group(10)));
            }
        }
        return components;
    }

    private static List<Component> parseInlineCode(String text) {
        List<Component> components = new ArrayList<>();
        Matcher matcher = INLINE_CODE_PATTERN.matcher(text);

        int last = 0;
        while (matcher.find()) {
            if (matcher.start() > last) {
                components.add(Component.literal(text.substring(last, matcher.start())));
            }
            components.add(Component.literal(matcher.group(1))
                    .withStyle(style -> style
                            .withColor(TextColor.fromRgb(0xAAAAAA))
                            .withFont(ResourceLocation.tryParse("minecraft:default"))
                    ));
            last = matcher.end();
        }

        if (last < text.length()) {
            components.add(Component.literal(text.substring(last)));
        }

        return components;
    }

    private static Component getReasoningContentComponent(String reason) {
        return Component.literal("[think] ")
                .setStyle(
                        Style.EMPTY.withHoverEvent(
                                new HoverEvent(
                                        HoverEvent.Action.SHOW_TEXT,
                                        Component.translatable("mcllm.reply.think").append(reason)
                                )
                        )
                );
    }
}
